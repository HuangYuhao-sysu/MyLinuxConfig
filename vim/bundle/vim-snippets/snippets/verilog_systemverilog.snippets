# if statement
snippet if
    if (${1}) begin
        ${0}
    end
# If/else statements
snippet ife
    if (${1}) begin
        ${2}
    end
    else begin
        ${3}
    end
# Else if statement
snippet eif
    else if (${1}) begin
        ${0}
    end
#Else statement
snippet el
    else begin
        ${0}
    end
# While statement
snippet wh
    while (${1}) begin
        ${0}
    end
# Repeat Loop
snippet rep
    repeat (${1}) begin
        ${0}
    end
# Case statement
snippet case
    case (${1:/* variable */})
        ${2:/* value */}: begin
            ${3}
        end
        default: begin
            ${4}
        end
    endcase
# CaseZ statement
snippet casez
    casez (${1:/* variable */})
        ${2:/* value */}: begin
            ${3}
        end
        default: begin
            ${4}
        end
    endcase
# Always block
snippet al
    always @(${1:/* sensitive list */}) begin
        ${0}
    end
# Module block
snippet mod
    module ${1:`vim_snippets#Filename('$1', 'name')`} #(
        ${0}
    ) (
        ${1}
    );
        ${2}
    endmodule
# For
snippet for
    for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) begin
        ${4}
    end
# Forever
snippet forev
    forever begin
        ${0}
    end
# Function
snippet fun
    function ${1:void} ${2:name}(${3});
        ${0}
    endfunction: $2
# Task
snippet task
    task ${1:name}(${2});
        ${0}
    endtask: $1
# Initial 
snippet ini
    initial begin
        ${0}
    end
# typedef struct packed
snippet tdsp
    typedef struct packed {
        int ${2:data};
    } ${1:`vim_snippets#Filename('$1_t', 'name')`};
# typedef eum
snippet tde
    typedef enum ${2:logic[15:0]}
    {
        ${3:REG = 16'h0000}
    } ${1:my_dest_t};
# Foreach Loop
snippet forea
    foreach (${1}) begin
        ${0}
    end
# Do-while statement
snippet dowh
    do begin
        ${0}
    end while (${1});
# Combinational always block
snippet alc
    always_comb begin ${1:: statement_label}
        ${0}
    end $1
# Sequential logic
snippet alff
    always_ff @(posedge ${1:clk}) begin ${2:: statement_label}
        ${0}
    end $2
# Latched logic
snippet all
    always_latch begin ${1:: statement_label}
        ${0}
    end $1
# Class
snippet cl
    class ${1:class_name};
        // data or class properties
        ${0}

        // initialization
        function new();
        endfunction : new

    endclass : $1
# Typedef structure
snippet types
    typedef struct {
        ${0}
    } ${1:name_t};
# Program block
snippet prog
    program ${1:program_name} ();
        ${0}
    endprogram : $1
# Interface block
snippet intf
    interface ${1:program_name} ();
        // nets
        ${0}
        // clocking

        // modports

    endinterface : $1
# Clocking Block
snippet clock
    clocking ${1:clocking_name} @(${2:posedge} ${3:clk});
        ${0}
    endclocking : $1
# Covergroup construct
snippet cg
    covergroup ${1:group_name} @(${2:posedge} ${3:clk});
        ${0}
    endgroup : $1
# Package declaration
snippet pkg
    package ${1:package_name};
        ${0}
    endpackage : $1
# annotation 1
snippet //-
    //-------------------------
    // ${0}
    //-------------------------
# annotation 2
snippet //--
    //------------------------------------------------------------------------------
    // ${0}
    //------------------------------------------------------------------------------
# input logic
snippet inp
    input  logic
# output logic
snippet outp
    output logic
# parameter
snippet para
    parameter
# flop_en
snippet alffen
    always_ff @(posedge clk or negedge reset_n) begin
        if (~reset_n) begin
            ${1:flop_name} <= '0;
        end
        else if ( $1_en ) begin
            $1 <= $1_next;
        end
    end
# flop_en
snippet alff
    always_ff @(posedge clk or negedge reset_n) begin
        if (~reset_n) begin
            ${1:flop_name} <= '0;
        end
        else begin
            $1 <= $1_next;
        end
    end
# `ifdef
snippet `if
    \`ifdef ${1:define}
    \`endif
snippet be
    begin
        ${1}
    end
# parameter
snippet par
    parameter 
# gen
snippet gen
    generate;
        
    endgenerate
# for
snippet for
    for (${1} = ; ; ) begin
        
    end
# always_comb
snippet alc
    always_comb begin
        ${1}
    end
snippet fun
    function ${1:return_value name} (${2:port_list});
        ${3}
    endfunction
